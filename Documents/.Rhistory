cors <- dat0 %>% group_by(gene) %>%
do(data.frame(
t(summary(coxph(Surv(DSS.time, DSS.status == "Dead") ~ zexpression,
data = .,
eps = 1e-4))$coefficients[c(1,5)]))
)
cors <- cors[unlist(cors$X2) < .005, ]
n.gen.cands <- 3:nrow(cors)
n.genes
sel.genes <- cors$gene[rank(-abs(cors$X1)) <= n.genes]
sel.genes <- cors$gene[rank(-abs(cors$X1)) <= n.genes]
coeffs <- cors$X1[rank(-abs(cors$X1)) <= n.genes]
coeffs
pcas
sel.genes
colnames(pcas)
sort(colnames(pcas))
dat0$gene == "200885_at"
table(dat0$gene == "200885_at")
table(dat0$gene == "200885_at", dat0$Post.Surgical.Treatment)
subset(dat0, gene == "200885_at")
dim(pcas)
length(sel.genes)
pcas
colnames(pcamat)
sel.genes
sel.genes <- cors$gene[rank(-abs(cors$X1)) <= n.genes]
coeffs <- cors$X1[rank(-abs(cors$X1)) <= n.genes]
pcas <- dat0 %>% select(ID, gene, zexpression) %>%
filter(gene %in% sel.genes) %>% spread(gene, zexpression)
pcamat <- as.matrix(pcas[, -1])
colnames(pcamat)
sel.genes
rownames(pcamat) <- pcas$ID
pc.fit <- prcomp(pcamat, center = FALSE, scale. = FALSE)
pc.dat <- as.data.frame(pc.fit$x[, 1:10])
pc.dat$ID <- rownames(pc.dat)
pdonk <- merge(cldat, pc.dat, by = "ID")
fit.cox <- coxph(Surv(DSS.time, DSS.status == "Dead") ~ PC1 + PC2 + PC3 + PC4 + PC5, data = pdonk)
summary(fit.cox)$concordance[1]
coeffs
sel.genes
colnames(pcamat)
colnames(pcamat) == sel.genes
pcamat[1:4,]
matrix(rep(coeffs, nrow(pcas)), nrow = nrow(pcas), byrow = TRUE)
cors <- cors[unlist(cors$X2) < .005, ]
n.gen.cands <- 3:nrow(cors)
p.ngenes <- sapply(n.gen.cands, function(n.genes){
sel.genes <- cors$gene[rank(-abs(cors$X1)) <= n.genes]
coeffs <- cors$X1[rank(-abs(cors$X1)) <= n.genes]
pcas <- dat0 %>% select(ID, gene, zexpression) %>%
filter(gene %in% sel.genes) %>% spread(gene, zexpression)
pcamat <- as.matrix(pcas[, -1]) * matrix(rep(coeffs, nrow(pcas)), nrow = nrow(pcas), byrow = TRUE)
rownames(pcamat) <- pcas$ID
pc.fit <- prcomp(pcamat, center = FALSE, scale. = FALSE)
pc.dat <- as.data.frame(pc.fit$x[, 1:10])
pc.dat$ID <- rownames(pc.dat)
pdonk <- merge(cldat, pc.dat, by = "ID")
fit.cox <- coxph(Surv(DSS.time, DSS.status == "Dead") ~ PC1 + PC2 + PC3 + PC4 + PC5, data = pdonk)
summary(fit.cox)$concordance[1]
})
cors <- cors[unlist(cors$X2) < .005, ]
n.gen.cands <- 5:nrow(cors)
p.ngenes <- sapply(n.gen.cands, function(n.genes){
sel.genes <- cors$gene[rank(-abs(cors$X1)) <= n.genes]
coeffs <- cors$X1[rank(-abs(cors$X1)) <= n.genes]
pcas <- dat0 %>% select(ID, gene, zexpression) %>%
filter(gene %in% sel.genes) %>% spread(gene, zexpression)
pcamat <- as.matrix(pcas[, -1]) * matrix(rep(coeffs, nrow(pcas)), nrow = nrow(pcas), byrow = TRUE)
rownames(pcamat) <- pcas$ID
pc.fit <- prcomp(pcamat, center = FALSE, scale. = FALSE)
pc.dat <- as.data.frame(pc.fit$x[, 1:5])
pc.dat$ID <- rownames(pc.dat)
pdonk <- merge(cldat, pc.dat, by = "ID")
fit.cox <- coxph(Surv(DSS.time, DSS.status == "Dead") ~ PC1 + PC2 + PC3 + PC4 + PC5, data = pdonk)
summary(fit.cox)$concordance[1]
})
p.ngenes
hist(p.ngenes)
n.gen.cands[which(order(-abs(p.ngenes)) == 1)]
p.ngenes[order(-abs(p.ngenes))]
p.ngenes[order(-abs(p.ngenes))][1]
library(survival)
library(tidyr)
library(dplyr)
load("../Data/jbl10-data-2016-02-09.RData")
## supervised pca fit for heldout
##    - select x most correlated genes
##    - subset those, form 3 pcas
##    - Fit multivariate model
## cutpoint at median
## predict for held in dataset
scl.cen <- function(x){
(x - mean(x, na.rm = TRUE))/sd(x, na.rm = TRUE)
}
## dichotomize survival
gdat$DSS.status[gdat$DSS.status == "dead"] <- "Dead"
gdat$surv2.5 <- with(gdat, ifelse(DSS.time >= 5, 1, -1))
psdex <- 2:(grep("tissue", colnames(gdat)) - 1)
gdat[, psdex] <- lapply(gdat[, psdex], scl.cen)
ldat <- gather_(gdat, "gene", "expression", colnames(gdat[, psdex]))
ldat <- ldat %>% group_by(gene) %>% mutate(zexpression = (expression - mean(expression, na.rm = TRUE))/sd(expression, na.rm = TRUE))
cldat <- gdat[, -psdex]
fit.superpc <- function(dat0, cldat){
cors <- dat0 %>% group_by(gene) %>%
do(data.frame(
t(summary(coxph(Surv(DSS.time, DSS.status == "Dead") ~ zexpression,
data = .,
eps = 1e-4))$coefficients[c(1,5)]))
)
## select number of genes
cors <- cors[unlist(cors$X2) < .005, ]
n.gen.cands <- 5:nrow(cors)
p.ngenes <- sapply(n.gen.cands, function(n.genes){
sel.genes <- cors$gene[rank(-abs(cors$X1)) <= n.genes]
coeffs <- cors$X1[rank(-abs(cors$X1)) <= n.genes]
pcas <- dat0 %>% select(ID, gene, zexpression) %>%
filter(gene %in% sel.genes) %>% spread(gene, zexpression)
pcamat <- as.matrix(pcas[, -1]) * matrix(rep(coeffs, nrow(pcas)), nrow = nrow(pcas), byrow = TRUE)
rownames(pcamat) <- pcas$ID
pc.fit <- prcomp(pcamat, center = FALSE, scale. = FALSE)
pc.dat <- as.data.frame(pc.fit$x[, 1:5])
pc.dat$ID <- rownames(pc.dat)
pdonk <- merge(cldat, pc.dat, by = "ID")
fit.cox <- coxph(Surv(DSS.time, DSS.status == "Dead") ~ PC1 + PC2 + PC3 + PC4 + PC5, data = pdonk)
summary(fit.cox)$concordance[1]
})
n.gene.sel <- n.gen.cands[which(order(-abs(p.ngenes)) == 1)]
sel.genes <- cors$gene[rank(unlist(cors$cor)) <= n.gene.sel]
pcas <- dat0 %>% select(ID, gene, zexpression) %>%
filter(gene %in% sel.genes) %>% spread(gene, zexpression)
pcamat <- as.matrix(pcas[, -1])
rownames(pcamat) <- pcas$ID
pc.fit <- prcomp(pcamat, center = FALSE, scale. = FALSE)
pc.dat <- as.data.frame(pc.fit$x[, 1:5])
pc.dat$ID <- rownames(pc.dat)
pdonk <- merge(cldat, pc.dat, by = "ID")
fit.cox <- coxph(Surv(DSS.time, DSS.status == "Dead") ~ PC1 + PC2 + PC3 + PC4 + PC5, data = pdonk)
lps <- predict(fit.cox, type = 'lp')
## middle 75%
c.cands <- sort(lps)[floor(.25 * length(lps)):floor(.75 * length(lps))]
p.cands <- sapply(c.cands, function(c.cand){
ltest <- survdiff(Surv(pdonk$DSS.time, pdonk$DSS.status == "Dead") ~ I(lps > c.cand))
pchisq(ltest$chisq, df = 1, lower.tail = FALSE)
})
cutoff <- c.cands[which(order(p.cands) == 1)]
list(pc.fit = pc.fit, cox.fit = fit.cox, cutoff = cutoff)
}
predict.superpc <- function(dat0, las.fit){
pcests <- predict(las.fit$pc.fit, newdata = dat0)[, 1:3]
dat0 <- cbind(dat0, pcests)
coxests <- predict(las.fit$cox.fit, newdata = dat0, type = 'lp')
list(lps = coxests, riskgrp = coxests > las.fit$cutoff)
}
eval.predict <- function(dat0, las.fit){
lpreds <- predict.superpc(dat0, las.fit)
sc <- survConcordance(Surv(dat0$DSS.time, dat0$DSS.status == "Dead") ~ lpreds$lps)
disc <- coxph(Surv(dat0$DSS.time, dat0$DSS.status == "Dead") ~ lpreds$riskgrp)$coefficients
c(calib = sc$concordance, discrim = disc)
}
## substitution estimate using full dataset
fit.all <- fit.superpc(subset(ldat, Post.Surgical.Treatment == "OBS"), cldat)
#fit.obs <- fit.superpc(ldat, cldat)
fitted <- predict.superpc(subset(gdat, Post.Surgical.Treatment == "OBS"), fit.all)
eval.predict(subset(gdat, Post.Surgical.Treatment == "OBS"), fit.all)
## partial resubstitution
dat0 <-
subset(ldat, Post.Surgical.Treatment == "OBS")
cors <- dat0 %>% group_by(gene) %>%
do(data.frame(
t(summary(coxph(Surv(DSS.time, DSS.status == "Dead") ~ zexpression,
data = .,
eps = 1e-4))$coefficients[c(1,5)]))
)
## select number of genes
cors <- cors[unlist(cors$X2) < .005, ]
n.gen.cands <- 5:nrow(cors)
p.ngenes <- sapply(n.gen.cands, function(n.genes){
sel.genes <- cors$gene[rank(-abs(cors$X1)) <= n.genes]
coeffs <- cors$X1[rank(-abs(cors$X1)) <= n.genes]
pcas <- dat0 %>% select(ID, gene, zexpression) %>%
filter(gene %in% sel.genes) %>% spread(gene, zexpression)
pcamat <- as.matrix(pcas[, -1]) * matrix(rep(coeffs, nrow(pcas)), nrow = nrow(pcas), byrow = TRUE)
rownames(pcamat) <- pcas$ID
pc.fit <- prcomp(pcamat, center = FALSE, scale. = FALSE)
pc.dat <- as.data.frame(pc.fit$x[, 1:5])
pc.dat$ID <- rownames(pc.dat)
pdonk <- merge(cldat, pc.dat, by = "ID")
fit.cox <- coxph(Surv(DSS.time, DSS.status == "Dead") ~ PC1 + PC2 + PC3 + PC4 + PC5, data = pdonk)
summary(fit.cox)$concordance[1]
})
n.gene.sel <- n.gen.cands[which(order(-abs(p.ngenes)) == 1)]
sel.genes <- cors$gene[rank(unlist(cors$cor)) <= n.gene.sel]
pcas <- dat0 %>% select(ID, gene, zexpression) %>%
filter(gene %in% sel.genes) %>% spread(gene, zexpression)
pcamat <- as.matrix(pcas[, -1])
rownames(pcamat) <- pcas$ID
pc.fit <- prcomp(pcamat, center = FALSE, scale. = FALSE)
pc.dat <- as.data.frame(pc.fit$x[, 1:5])
pc.dat$ID <- rownames(pc.dat)
pdonk <- merge(cldat, pc.dat, by = "ID")
fit.cox <- coxph(Surv(DSS.time, DSS.status == "Dead") ~ PC1 + PC2 + PC3 + PC4 + PC5, data = pdonk)
n.gene.sel <- n.gen.cands[which(order(-abs(p.ngenes)) == 1)]
sel.genes <- cors$gene[rank(-abs(cors$X1)) <= n.gene.sel]
pcas <- dat0 %>% select(ID, gene, zexpression) %>%
filter(gene %in% sel.genes) %>% spread(gene, zexpression)
pcamat <- as.matrix(pcas[, -1])
rownames(pcamat) <- pcas$ID
fit.superpc <- function(dat0, cldat){
cors <- dat0 %>% group_by(gene) %>%
do(data.frame(
t(summary(coxph(Surv(DSS.time, DSS.status == "Dead") ~ zexpression,
data = .,
eps = 1e-4))$coefficients[c(1,5)]))
)
## select number of genes
cors <- cors[unlist(cors$X2) < .005, ]
n.gen.cands <- 5:nrow(cors)
p.ngenes <- sapply(n.gen.cands, function(n.genes){
sel.genes <- cors$gene[rank(-abs(cors$X1)) <= n.genes]
coeffs <- cors$X1[rank(-abs(cors$X1)) <= n.genes]
pcas <- dat0 %>% select(ID, gene, zexpression) %>%
filter(gene %in% sel.genes) %>% spread(gene, zexpression)
pcamat <- as.matrix(pcas[, -1]) * matrix(rep(coeffs, nrow(pcas)), nrow = nrow(pcas), byrow = TRUE)
rownames(pcamat) <- pcas$ID
pc.fit <- prcomp(pcamat, center = FALSE, scale. = FALSE)
pc.dat <- as.data.frame(pc.fit$x[, 1:5])
pc.dat$ID <- rownames(pc.dat)
pdonk <- merge(cldat, pc.dat, by = "ID")
fit.cox <- coxph(Surv(DSS.time, DSS.status == "Dead") ~ PC1 + PC2 + PC3 + PC4 + PC5, data = pdonk)
summary(fit.cox)$concordance[1]
})
n.gene.sel <- n.gen.cands[which(order(-abs(p.ngenes)) == 1)]
sel.genes <- cors$gene[rank(-abs(cors$X1)) <= n.gene.sel]
pcas <- dat0 %>% select(ID, gene, zexpression) %>%
filter(gene %in% sel.genes) %>% spread(gene, zexpression)
pcamat <- as.matrix(pcas[, -1])
rownames(pcamat) <- pcas$ID
pc.fit <- prcomp(pcamat, center = FALSE, scale. = FALSE)
pc.dat <- as.data.frame(pc.fit$x[, 1:5])
pc.dat$ID <- rownames(pc.dat)
pdonk <- merge(cldat, pc.dat, by = "ID")
fit.cox <- coxph(Surv(DSS.time, DSS.status == "Dead") ~ PC1 + PC2 + PC3 + PC4 + PC5, data = pdonk)
lps <- predict(fit.cox, type = 'lp')
## middle 75%
c.cands <- sort(lps)[floor(.25 * length(lps)):floor(.75 * length(lps))]
p.cands <- sapply(c.cands, function(c.cand){
ltest <- survdiff(Surv(pdonk$DSS.time, pdonk$DSS.status == "Dead") ~ I(lps > c.cand))
pchisq(ltest$chisq, df = 1, lower.tail = FALSE)
})
cutoff <- c.cands[which(order(p.cands) == 1)]
list(pc.fit = pc.fit, cox.fit = fit.cox, cutoff = cutoff)
}
predict.superpc <- function(dat0, las.fit){
pcests <- predict(las.fit$pc.fit, newdata = dat0)[, 1:3]
dat0 <- cbind(dat0, pcests)
coxests <- predict(las.fit$cox.fit, newdata = dat0, type = 'lp')
list(lps = coxests, riskgrp = coxests > las.fit$cutoff)
}
eval.predict <- function(dat0, las.fit){
lpreds <- predict.superpc(dat0, las.fit)
sc <- survConcordance(Surv(dat0$DSS.time, dat0$DSS.status == "Dead") ~ lpreds$lps)
disc <- coxph(Surv(dat0$DSS.time, dat0$DSS.status == "Dead") ~ lpreds$riskgrp)$coefficients
c(calib = sc$concordance, discrim = disc)
}
## substitution estimate using full dataset
fit.all <- fit.superpc(subset(ldat, Post.Surgical.Treatment == "OBS"), cldat)
#fit.obs <- fit.superpc(ldat, cldat)
fitted <- predict.superpc(subset(gdat, Post.Surgical.Treatment == "OBS"), fit.all)
eval.predict(subset(gdat, Post.Surgical.Treatment == "OBS"), fit.all)
## partial resubstitution
predict.superpc <- function(dat0, las.fit){
pcests <- predict(las.fit$pc.fit, newdata = dat0)[, 1:5]
dat0 <- cbind(dat0, pcests)
coxests <- predict(las.fit$cox.fit, newdata = dat0, type = 'lp')
list(lps = coxests, riskgrp = coxests > las.fit$cutoff)
}
eval.predict <- function(dat0, las.fit){
lpreds <- predict.superpc(dat0, las.fit)
sc <- survConcordance(Surv(dat0$DSS.time, dat0$DSS.status == "Dead") ~ lpreds$lps)
disc <- coxph(Surv(dat0$DSS.time, dat0$DSS.status == "Dead") ~ lpreds$riskgrp)$coefficients
c(calib = sc$concordance, discrim = disc)
}
fitted <- predict.superpc(subset(gdat, Post.Surgical.Treatment == "OBS"), fit.all)
eval.predict(subset(gdat, Post.Surgical.Treatment == "OBS"), fit.all)
exp(1.7)
library(survival)
library(tidyr)
library(dplyr)
load("../Data/jbl10-data-2016-02-09.RData")
## supervised pca fit for heldout
##    - select x most correlated genes
##    - subset those, form 3 pcas
##    - Fit multivariate model
## cutpoint at median
## predict for held in dataset
scl.cen <- function(x){
(x - mean(x, na.rm = TRUE))/sd(x, na.rm = TRUE)
}
## dichotomize survival
gdat$DSS.status[gdat$DSS.status == "dead"] <- "Dead"
gdat$surv2.5 <- with(gdat, ifelse(DSS.time >= 5, 1, -1))
psdex <- 2:(grep("tissue", colnames(gdat)) - 1)
gdat[, psdex] <- lapply(gdat[, psdex], scl.cen)
ldat <- gather_(gdat, "gene", "expression", colnames(gdat[, psdex]))
ldat <- ldat %>% group_by(gene) %>% mutate(zexpression = (expression - mean(expression, na.rm = TRUE))/sd(expression, na.rm = TRUE))
cldat <- gdat[, -psdex]
fit.superpc <- function(dat0, cldat){
cors <- dat0 %>% group_by(gene) %>%
do(data.frame(
t(summary(coxph(Surv(DSS.time, DSS.status == "Dead") ~ zexpression,
data = .,
eps = 1e-4))$coefficients[c(1,5)]))
)
## select number of genes
cors <- cors[unlist(cors$X2) < .005, ]
n.gen.cands <- 5:nrow(cors)
p.ngenes <- sapply(n.gen.cands, function(n.genes){
sel.genes <- cors$gene[rank(-abs(cors$X1)) <= n.genes]
coeffs <- cors$X1[rank(-abs(cors$X1)) <= n.genes]
pcas <- dat0 %>% select(ID, gene, zexpression) %>%
filter(gene %in% sel.genes) %>% spread(gene, zexpression)
pcamat <- as.matrix(pcas[, -1]) * matrix(rep(coeffs, nrow(pcas)), nrow = nrow(pcas), byrow = TRUE)
rownames(pcamat) <- pcas$ID
pc.fit <- prcomp(pcamat, center = TRUE, scale. = TRUE)
pc.dat <- as.data.frame(pc.fit$x[, 1:5])
pc.dat$ID <- rownames(pc.dat)
pdonk <- merge(cldat, pc.dat, by = "ID")
fit.cox <- coxph(Surv(DSS.time, DSS.status == "Dead") ~ PC1 + PC2 + PC3 + PC4 + PC5, data = pdonk)
summary(fit.cox)$concordance[1]
})
n.gene.sel <- n.gen.cands[which(order(-abs(p.ngenes)) == 1)]
sel.genes <- cors$gene[rank(-abs(cors$X1)) <= n.gene.sel]
pcas <- dat0 %>% select(ID, gene, zexpression) %>%
filter(gene %in% sel.genes) %>% spread(gene, zexpression)
pcamat <- as.matrix(pcas[, -1])
rownames(pcamat) <- pcas$ID
pc.fit <- prcomp(pcamat, center = FALSE, scale. = FALSE)
pc.dat <- as.data.frame(pc.fit$x[, 1:5])
pc.dat$ID <- rownames(pc.dat)
pdonk <- merge(cldat, pc.dat, by = "ID")
fit.cox <- coxph(Surv(DSS.time, DSS.status == "Dead") ~ PC1 + PC2 + PC3 + PC4 + PC5, data = pdonk)
lps <- predict(fit.cox, type = 'lp')
## middle 75%
c.cands <- sort(lps)[floor(.25 * length(lps)):floor(.75 * length(lps))]
p.cands <- sapply(c.cands, function(c.cand){
ltest <- survdiff(Surv(pdonk$DSS.time, pdonk$DSS.status == "Dead") ~ I(lps > c.cand))
pchisq(ltest$chisq, df = 1, lower.tail = FALSE)
})
cutoff <- c.cands[which(order(p.cands) == 1)]
list(pc.fit = pc.fit, cox.fit = fit.cox, cutoff = cutoff)
}
predict.superpc <- function(dat0, las.fit){
pcests <- predict(las.fit$pc.fit, newdata = dat0)[, 1:5]
dat0 <- cbind(dat0, pcests)
coxests <- predict(las.fit$cox.fit, newdata = dat0, type = 'lp')
list(lps = coxests, riskgrp = coxests > las.fit$cutoff)
}
eval.predict <- function(dat0, las.fit){
lpreds <- predict.superpc(dat0, las.fit)
sc <- survConcordance(Surv(dat0$DSS.time, dat0$DSS.status == "Dead") ~ lpreds$lps)
disc <- coxph(Surv(dat0$DSS.time, dat0$DSS.status == "Dead") ~ lpreds$riskgrp)$coefficients
c(calib = sc$concordance, discrim = disc)
}
## substitution estimate using full dataset
fit.all <- fit.superpc(subset(ldat, Post.Surgical.Treatment == "OBS"), cldat)
#fit.obs <- fit.superpc(ldat, cldat)
fitted <- predict.superpc(subset(gdat, Post.Surgical.Treatment == "OBS"), fit.all)
eval.predict(subset(gdat, Post.Surgical.Treatment == "OBS"), fit.all)
## partial resubstitution
?choose
nrow(cors)
choose(200, 15)
dat0 <- subset(ldat, Post.Surgical.Treatment == "OBS")
cors <- dat0 %>% group_by(gene) %>%
do(data.frame(
t(summary(coxph(Surv(DSS.time, DSS.status == "Dead") ~ zexpression,
data = .,
eps = 1e-4))$coefficients[c(1,5)]))
)
## select number of genes
cors <- cors[unlist(cors$X2) < .005, ]
cors <- cors[cors$X2 < .005, ]
cors
seldat0 <- dat0 %>% filter(gene %in% cors$gene) %>%
spread(gene, zexpression)
seldat0 <- select(ID, gene, zexpression) %>%
filter(gene %in% sel.genes) %>% spread(gene, zexpression)
seldat0 <- dat0 %>% select(ID, gene, zexpression) %>%
filter(gene %in% sel.genes) %>% spread(gene, zexpression)
seldat0 <- dat0 %>% select(ID, gene, zexpression) %>%
filter(gene %in% cors$gene) %>% spread(gene, zexpression)
?spread
lapply(seldat0[, -1], function(it){
colnames(it)
})
lapply(2:ncol(seldat0), function(it){
cors %>% filter(gene == colnames(seldat[, it])) %>% `$`("X1") * seldat0[, it]
})
lapply(2:ncol(seldat0), function(it){
cors %>% filter(gene == colnames(seldat0[, it])) %>% `$`("X1") * seldat0[, it]
})
seldat0[, 2:ncol(seldat0)] <- lapply(2:ncol(seldat0), function(it){
cors %>% filter(gene == colnames(seldat0[, it])) %>% `$`("X1") * seldat0[, it]
})
seldat0
seldat0[,2]
load("../Code/cvsim-result.RData")
cvres <- do.call("rbind", cvsims)
cvres[1:4,]
colnames(cvres)
library(tidyr)
?gather
i <- 1
cl <- cvres[, i]
sapply(strsplit(colnames(cvres)[i], ".", fixed = TRUE), function(s) rev(s)[1])
splow <- strsplit(colnames(cvres)[i], ".", fixed = TRUE)
nm <- paste(sapply(splow, "[", 1:2), collpase = ".")
nm
paste(sapply(splow, "[", 1:2), sep = ".")
sapply(splow, "[", 1:2)
paste(unlist(sapply(splow, "[", 1:2)), collapse = ".")
sapply(splot, function(s) rev(s)[1])
sapply(splow, function(s) rev(s)[1])
cvlong <- lapply(1:ncol(cvres), function(i){
cl <- cvres[, i]
splow <- strsplit(colnames(cvres)[i], ".", fixed = TRUE)
nm <- paste(unlist(sapply(splow, "[", 1:2)), collapse = ".")
cls <- sapply(splow, function(s) rev(s)[1])
df <- data.frame(cvres[, i], stat = cls, stringsAsFactors = FALSE)
colnames(df)[1] <- nm
df
})
cvlong <- lapply(1:ncol(cvres), function(i){
cl <- cvres[, i]
splow <- strsplit(colnames(cvres)[i], ".", fixed = TRUE)
nm <- paste(unlist(sapply(splow, "[", 1:2)), collapse = ".")
cls <- sapply(splow, function(s) rev(s)[1])
data.frame(value = cvres[, i], stat = cls, scen = nm, stringsAsFactors = FALSE)
})
cvlong <- do.call("rbind", lapply(1:ncol(cvres), function(i){
cl <- cvres[, i]
splow <- strsplit(colnames(cvres)[i], ".", fixed = TRUE)
nm <- paste(unlist(sapply(splow, "[", 1:2)), collapse = ".")
cls <- sapply(splow, function(s) rev(s)[1])
data.frame(value = cvres[, i], stat = cls, scen = nm, stringsAsFactors = FALSE)
}))
library(ggplot2)
ggplot(subset(cvlong, stat == "AUC"), aes(y = value, x = scen)) + geom_boxplot()
table(cvlong(scen))
table(cvlong$scen)
cvlong <- do.call("rbind", lapply(1:ncol(cvres), function(i){
cl <- cvres[, i]
splow <- strsplit(colnames(cvres)[i], ".", fixed = TRUE)
nm <- paste(unlist(sapply(splow, function(s) rev(rev(s)[-1])), collapse = ".")
cls <- sapply(splow, function(s) rev(s)[1])
data.frame(value = cvres[, i], stat = cls, scen = nm, stringsAsFactors = FALSE)
}))
ggplot(subset(cvlong, stat == "AUC"), aes(y = value, x = scen)) + geom_boxplot()
cvlong <- do.call("rbind", lapply(1:ncol(cvres), function(i){
cl <- cvres[, i]
splow <- strsplit(colnames(cvres)[i], ".", fixed = TRUE)
nm <- paste(unlist(sapply(splow, function(s) rev(rev(s)[-1]))), collapse = ".")
cls <- sapply(splow, function(s) rev(s)[1])
data.frame(value = cvres[, i], stat = cls, scen = nm, stringsAsFactors = FALSE)
}))
ggplot(subset(cvlong, stat == "AUC"), aes(y = value, x = scen)) + geom_boxplot()
ggplot(subset(cvlong, stat == "AUC"), aes(y = value, x = scen)) + geom_violin()
ggplot(subset(cvlong, stat == "AUC"), aes(y = value, x = scen)) + geom_jitter() + geom_violin()
ggplot(subset(cvlong, stat == "AUC"), aes(y = value, x = scen)) + geom_violin() +
theme_bw(base_size = 13, base_family = "serif")
ggplot(subset(cvlong, stat == "AUC"), aes(y = value, x = scen)) + geom_violin(fill = "grey60") +
theme_bw(base_size = 13, base_family = "serif") +
scale_x_discrete("Estimation Approach", values = c("Bootstrap", "Leave 10 out CV", "Leave 100 out CV",
"30% Holdout", "50% Holdout", "Resubstitution", "Partial CV", "Partial Holdout"))
?scale_x_discrete
ggplot(subset(cvlong, stat == "AUC"), aes(y = value, x = scen)) + geom_violin(fill = "grey60") +
theme_bw(base_size = 13, base_family = "serif") +
scale_x_discrete("Estimation Approach", labels = c("Bootstrap", "Leave 10 out CV", "Leave 100 out CV",
"30% Holdout", "50% Holdout", "Resubstitution", "Partial CV", "Partial Holdout"))
ggplot(subset(cvlong, stat == "AUC"), aes(y = value, x = scen)) + geom_violin(fill = "grey60") +
theme_bw(base_size = 13, base_family = "serif") +
scale_x_discrete("Estimation Approach", labels = c("Bootstrap", "Leave 10 out CV", "Leave 100 out CV",
"30% Holdout", "50% Holdout", "Resubstitution", "Partial CV", "Partial Holdout")) +
ylab("Area Under the ROC Curve")
Y <- rnorm(100)
X <- Y + rnorm(100, sd = .5)
cor(X, Y)
Y <- rnorm(100)
X <- Y + rnorm(100)
cor(X, Y)
Y <- rnorm(100)
X <- Y + rnorm(100)
permcors <- rep(NA, 1000)
for(i in 1:1000){
permY <- sample(Y, length(Y), replace = FALSE)
permcors[i] <- cor(X, permY)
}
hist(permcors)
abline(v = cor(X, Y), col = "red")
permcors <- rep(NA, 10000)
for(i in 1:10000){
permY <- sample(Y, length(Y), replace = FALSE)
permcors[i] <- cor(X, permY)
}
hist(permcors)
abline(v = cor(X, Y), col = "red")
hist(permcors, freq = TRUE)
hist(permcors, freq = FALSE)
curve(dnorm(x), add = TRUE)
curve(dnorm(x, sd = 1/10), add = TRUE)
